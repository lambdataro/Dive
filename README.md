# プログラミング言語Dive
研究室の新入生向けゼミで扱ったHaskellでの簡単な関数型言語の実装例．

## 概要
プログラム言語 Dive は，以下の機能を搭載した静的型付けの関数型言語です。
- 型推論 (Algorithm M, 多相)
- 整数型, 実数型, 文字型, ユニット型, Bool 型
- リスト型, タプル型, 文字列型(文字のリスト), Either 型
- ラムダ計算, let 式, let rec 式, if 式, パターンマッチ (ガード付き)
- 単一行コメント, 複数行コメント, 型を明示する機能
- 実数の科学表示, 2進, 8進, 16進整数リテラル, エスケープシーケンス
Dive のインタプリタは，値呼び (call-by-value) の計算戦略に従って式の評価を行います。 言語は，OCaml と Haskell を足し合わせたような構文になっています。

## 実行方法
以下のコマンドを実行します．
```
$ runghc Main.hs test.dive
```

## プログラム例
### Hello, World.
```
-- 画面に表示する。
print "hello, world.¥n";
```
実行結果:
```
it :: ()
hello, world.
```

### fact関数
```
fact n =
  if n == 0 then 1
  else n * fact (n - 1);

print (fact 5);
```
実行結果:
```
fact :: (Int -> Int)
it :: ()
120
```

### let多相
```
fold f a lis =
  match lis {
    [] -> a;
    x:xs -> fold f (f a x) xs;
  };

-- テスト用リスト
test = [1,2,3,4,5,6,7,8,9,10];

-- value restriction は無い。
sum = fold (+) 0;
rev = fold (fun x y -> y:x) [];

print (sum test);
print "\n";
print (rev test);
print "\n";
```
実行結果
```
fold :: (('a -> ('b -> 'a)) -> ('a -> (['b] -> 'a)))
test :: [Int]
sum :: ([Int] -> Int)
rev :: (['a] -> ['a])
it :: ()
it :: ()
it :: ()
it :: ()
55
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

## リファレンスマニュアル
### トップレベル式
Dive のプログラムは文の列として表現されます。 文はセミコロンで終わり，定義文と式文の二種類があります。

式文:
```
式 ;
```
式文では式を評価してその値に it という変数を束縛します。

定義文:
```
変数名 = 式;
関数名 仮引数名1 仮引数名2 ... = 式;
```
定義文では式を評価して，その式に名前を付けます。 式の中で変数名や関数名を再帰的に使うことができます。

例:
```
double n = n * 2;    -- 定義文
print (double 5);    -- 式文
```

### コメント
コメントには，単一行コメントと複数行コメントがあります。 複数行コメントは入れ子にできます。
```
-- 単一行コメント
{- 複数行コメント -}
```

### Int型
整数型です。整数リテラルは 123 のような10進表記以外に， 2進表記 (0b1100), 8進表記 (0o777), 16進表記 (0xf0) が使えます。 演算子には，(+), (-), (*), (/), (%) があり，それぞれ加算，減算，乗算，除算，剰余です。 また，単項の - 演算子もあります。

### Double 型
倍精度浮動小数点数型です。リテラルは，3.14 のように小数点表記の他に， 6.02e23 のような科学表記が可能です。 演算子は，(+.), (-.), (*.), (/.) があり，単項のマイナスは -. です。

### Char型
文字型です。リテラルは，'A' のようにシングルクォーテーションマークで囲んで表します。 '¥n' のようにエスケープシーケンスも利用できます。

### Bool型
値 True と False があり，真偽値を表しています。 (&&) 演算子 と (||) 演算子で，論理積と論理和を表します。

### ()型
ユニット型です。値は () のみです。

### [a] 型
リスト型です。[1, 2, 3] のように値をコンマで区切って表現します。 リストの要素の型はすべて同じである必要があります。 リストの結合の演算子 (++) と，リストの先頭に要素を追加する演算子 (:) があります。

### String 型
[Char] の別名です。[Char] は常に String と表示されます。 "hello" のような文字列リテラルを書くこともできます。

### タプル型
タプルの型です。例えば，('a', 3) は (Char,Int) 型です。

### Either a b 型
Left a または Right b いずれかの値をとる型です。

### 無名関数
無名関数(ラムダ式)はOCaml風に次のように書きます。
```
fun 変数1 変数2 ... = 式
```
関数適用は，式を空白で区切って表します。
```
e1 e2 ...
```

### let式
```
let 変数 = 式1 in 式2
let 関数名 引数1 引数2 ... = 式1 in 式2
```
式1を評価して結果の値を変数に束縛し，式2を評価しその結果を返します。 型システムにより，可能であれば変数の型は多相型になります。 変数名や関数名を式1で使うことができません。

### let rec式
```
let rec 変数 = 式1 in 式2
let rec 関数名 引数1 引数2 ... = 式1 in 式2
```
let rec は let 式と違い，変数名や関数名を式1で使うことができます。

### if 式
```
if 式1 then 式2 else 式3
```
式1を評価して，True であれば 式2 を，False であれば 式3 を評価します。

### match式
```
match 式1 {
  パターン when ガード -> 式;
  パターン when ガード -> 式;
  ...
}
```
式1を評価して，その値にパターンマッチをします。 マッチするパターンが見つかると，本体の式が評価されます。 ガード式は省略可能です。

### パターン
以下のパターンがあります。
- リテラルパターン ( 3 とか True とか )
- ワイルドカードパターン ( _ )
- 変数パターン ( x など )
- cons パターン ( x : xs )
- リストパターン ( [a, b, c] )
- タプルパターン ( (a, b, c) )
- Either パターン ( Left x と Right y )
- 括弧で囲んだパターン ( ( x ) )

### 逐次処理式 †
```
{ 式1; 式2; ... }
```
式を順番に評価して，最後の式の値を返します。

### 型指定式
```
( 式 :: 型 )
```
式が指定の型を持つように強制します。

### 演算子関数
(+) のように演算子を括弧でかこむと，関数として利用できます。

### 中置関数
`f` のよに変数をバッククォートで囲むと，関数を演算子のように中置できます。

### 組み込み関数
= not (bool の否定)
- Reft (Either 型にする)
- Left (Either 型にする)
- print (式の値を表示する)
- chr (文字コードを文字にする)
- ord (文字を文字コードにする)
- toInt (浮動小数点数を整数にする)
- toDouble (整数を浮動小数点数にする)

















